import strutils, tables, deques, sets, sequtils

type
  Vec = tuple[x, y: int]
  Edge = enum Wall Door
  Node = tuple
    north, south, east, west: Edge
  Graph = Table[Vec, Node]
  FacilityMap = object
    startPos: Vec
    instructions: string
    graph: Graph
## Vector math helpers
proc `-`(a, b: Vec): Vec {.inline.} = (x: a.x - b.x, y: a.y - b.y)
proc `+`(a, b: Vec): Vec {.inline.} = (x: a.x + b.x, y: a.y + b.y)
proc north(a: Vec): Vec {.inline.} = a - (0,1)
proc south(a: Vec): Vec {.inline.} = a + (0,1)
proc east(a: Vec): Vec {.inline.} = a + (1,0)
proc west(a: Vec): Vec {.inline.} = a - (1,0)
#proc `<`(a, b: Vec): bool {.inline.} = (if a.y == b.y: a.x < b.x else: a.y < b.y)
#proc `*`(a: int, b: Vec): Vec {.inline.} = (x: a * b.x, y: a * b.y)
#proc inc(a: var Vec, b: Vec) {.inline.} = a = a + b
#proc dec(a: var Vec, b: Vec) {.inline.} = a = a - b
iterator neighbors(a: Vec): Vec =
  yield a.north
  yield a.east
  yield a.west
  yield a.south


proc initGraph(instructions: string, startPos: Vec = (0, 0)): Graph =
  result = initTable[Vec, Node]()
  var
    posStack: seq[Vec] = @[]
    curPos = startPos
  for c in instructions:
    echo "Current at ", curPos, " processing ", c, " with stack ", posStack
    case c
    of '^':
      result.add(startPos, (Wall, Wall, Wall, Wall))
    of 'N':
      result[curPos].north = Door
      curPos = curPos.north
      if result.hasKeyOrPut(curPos, (north: Wall, south: Door, east: Wall, west: Wall)):
        result[curPos].south = Door
    of 'S':
      result[curPos].south = Door
      curPos = curPos.south
      if result.hasKeyOrPut(curPos, (north: Door, south: Wall, east: Wall, west: Wall)):
        result[curPos].north = Door
    of 'E':
      result[curPos].east = Door
      curPos = curPos.east
      if result.hasKeyOrPut(curPos, (north: Wall, south: Wall, east: Wall, west: Door)):
        result[curPos].west = Door
    of 'W':
      result[curPos].west = Door
      curPos = curPos.west
      if result.hasKeyOrPut(curPos, (north: Wall, south: Wall, east: Door, west: Wall)):
        result[curPos].east = Door
    of '(':
      posStack.add(curPos)
    of ')':
      curPos = posStack.pop()
    of '|':
      curPos = posStack[^1]
    of '$':
      return result
    else: discard

proc breadthFirstSearch(graph: Graph, start, goal: Vec): seq[Vec] =
  ## Use breadth first search to find the shortest path between `start` and `goal`
  var
    openSet = initDeque[Vec]()
    closedSet = initSet[Vec]()
    cameFrom = initTable[Vec, Vec]()

  openSet.addLast(start)
  while openSet.len > 0:
    let current = openSet.popFirst()

    if current == goal:
      result = @[goal]
      var temp = current
      while cameFrom.hasKey(temp):
        temp = cameFrom[temp]
        result = @[temp].concat(result)
      return result[1..^1]

    


proc initFacilityMap(instructions: string, startPos: Vec = (0, 0)): FacilityMap =
  result = FacilityMap(
    startPos: startPos,
    instructions: instructions,
    graph: initGraph(instructions)
  )

proc findFarthestRoom(facility: FacilityMap): (Vec, int) =
  ## Test each room in the facility to see how many doors are on the shortest path
  ## to reach that room from the start. Return the location for the room who's path is
  ## the most doors away, as well as the number of doors.
  result = (facility.startPos, 0)
  for goalPos in facility.graph.keys:
    if goalPos != facility.startPos:
      let path = facility.graph.breadthFirstSearch(facility.startPos, goalPos)
      if path.len > result[1]:
        result = (goalPos, path.len)

when isMainModule:
  let input = readFile("./res/day20.txt").replace("\n", "")

  let testInput = "^ENWWW(NEEE|SSE(EE|N))$"
  echo initFacilityMap(testInput)
